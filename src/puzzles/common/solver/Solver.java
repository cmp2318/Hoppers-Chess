package puzzles.common.solver;

import java.util.*;

/**
 * @author Jose Thomas Diaz jtd4400
 */
public class Solver {
    /**
     * placeholder for configCount of type int
     */
    private int configCount;
    /**
     * placeholder for map of type HashMap, holds Configurations as keys and Configurations and values
     */
    private static HashMap<Configuration, Configuration> map = new HashMap<>();
    /**
     * placeholder for queue of type List, holds Configurations
     */
    private static List<Configuration> queue = new LinkedList<>();
    /**
     * placeholder for solution of type Configuration
     */
    private static Configuration solution;
    /**
     * placeholder for totalConfigs of type int
     */
    private static int totalConfigs;
    /**
     * placeholder for uniqueConfigs of type int
     */
    private static int uniqueConfigs;

    /**
     * Get the total number of configurations generated by a puzzle until a solution was found
     * @return int
     */
    public static int getTotalConfigs() {
        return totalConfigs;
    }

    /**
     * Get the amount of unique configurations generated by a puzzle until a solution was found
     * @return int
     */
    public static int getUniqueConfigs() {
        return uniqueConfigs;
    }

    public static void clearQueue(){
        queue.clear();
    }

    /**
     * Solves a given configuration using BFS
     * @param config Configuration that will be solved
     * @return List<String> that represents the path found by the solver
     */
    public static List<String> solve(Configuration config) {

        queue.add(config);

        map.put(config, null);
        totalConfigs++;
        uniqueConfigs++;
        while (!queue.isEmpty()) {
            Configuration now = queue.remove(0);
            if (now.isSolution()) {
                solution = now;
                break;
            }

            for (Configuration c: now.getNeighbors()) {
                totalConfigs++;
                if (!map.containsKey(c)) {
                    map.put(c, now);
                    queue.add(c);
                    uniqueConfigs++;
                }
            }
        }
        return constructPath(map, config, solution);
    }

    /**
     * Find the shortest path between two Configurations
     * @param predecessors HashMap<Configuration, Configuration> representing the predecessor map built previously
     * @param begin Configuration representing the starting Configuration
     * @param end Configuration representing the destination Configuration
     * @return List<String> that represents the shortest path between the Configurations
     */
    private static List<String> constructPath(HashMap<Configuration, Configuration> predecessors, Configuration begin, Configuration end) {
        List<String> path = new LinkedList<>();
        if (predecessors.containsKey(end)) {
            Configuration current = end;
            while (!current.equals(begin)) {
                path.add(0, current.toString());
                current = predecessors.get(current);
            }

            path.add(0, begin.toString());
        }
        return path;
    }
}
